/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BacklinkCachePlugin
});
module.exports = __toCommonJS(main_exports);

// src/CustomArrayDictImpl.ts
var CustomArrayDictImpl = class {
  constructor() {
    __publicField(this, "data", {});
  }
  add(key, value) {
    if (!this.data.hasOwnProperty(key)) {
      this.data[key] = [];
    }
    const values = this.data[key];
    if (!values.includes(value)) {
      values.push(value);
    }
  }
  remove(key, value) {
    const values = this.data[key];
    if (!values) {
      return;
    }
    values.remove(value);
    if (values.length === 0) {
      delete this.data[key];
    }
  }
  removeKey(key) {
    delete this.data[key];
  }
  get(key) {
    return this.data.hasOwnProperty(key) ? this.data[key] : null;
  }
  keys() {
    return Object.keys(this.data);
  }
  clear(key) {
    delete this.data[key];
  }
  clearAll() {
    this.data = {};
  }
  contains(key, value) {
    const values = this.data[key];
    return values && values.contains(value) || false;
  }
  count() {
    let ans = 0;
    for (const key in this.data) {
      if (this.data.hasOwnProperty(key)) {
        ans += this.data[key].length;
      }
    }
    return ans;
  }
};

// src/OriginalFunc.ts
function setOriginalFunc(func, originalFunc) {
  func.originalFunc = originalFunc;
}

// src/BacklinkCachePlugin.ts
var import_obsidian = require("obsidian");
var BacklinkCachePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "linksMap", /* @__PURE__ */ new Map());
    __publicField(this, "backlinksMap", /* @__PURE__ */ new Map());
    __publicField(this, "DEBOUNCE_TIMEOUT_IN_MILLISECONDS", 1e3);
    __publicField(this, "handlersQueue", []);
    __publicField(this, "processHandlersQueueDebounced", (0, import_obsidian.debounce)(this.processHandlersQueue.bind(this), this.DEBOUNCE_TIMEOUT_IN_MILLISECONDS));
  }
  onload() {
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
  }
  onLayoutReady() {
    const noteFiles = this.app.vault.getMarkdownFiles().sort((a, b) => a.path.localeCompare(b.path));
    console.log(`Processing ${noteFiles.length} note files`);
    let i = 0;
    for (const noteFile of noteFiles) {
      i++;
      console.debug(`Processing ${i} / ${noteFiles.length} - ${noteFile.path}`);
      const cache = this.app.metadataCache.getFileCache(noteFile);
      if (cache) {
        this.processBacklinks(cache, noteFile.path);
      }
    }
    const originalFunc = this.app.metadataCache.getBacklinksForFile;
    this.app.metadataCache.getBacklinksForFile = this.getBacklinksForFile.bind(this);
    setOriginalFunc(this.app.metadataCache.getBacklinksForFile, originalFunc.bind(this.app.metadataCache));
    this.registerEvent(this.app.metadataCache.on("changed", this.makeDebounced(this.handleMetadataChanged.bind(this))));
    this.registerEvent(this.app.vault.on("rename", this.makeDebounced(this.handleFileRename.bind(this))));
    this.registerEvent(this.app.vault.on("delete", this.makeDebounced(this.handleFileDelete.bind(this))));
    this.register(() => {
      this.app.metadataCache.getBacklinksForFile = originalFunc;
    });
  }
  makeDebounced(handler) {
    return (...args) => {
      this.handlersQueue.push(() => handler(...args));
      this.processHandlersQueueDebounced();
    };
  }
  processHandlersQueue() {
    while (true) {
      const handler = this.handlersQueue.shift();
      if (!handler) {
        return;
      }
      handler();
    }
  }
  handleMetadataChanged(file, _data, cache) {
    console.debug(`Handling cache change for ${file.path}`);
    this.removeLinkedPathEntries(file.path);
    this.processBacklinks(cache, file.path);
  }
  handleFileRename(file, oldPath) {
    console.debug(`Handling rename from ${oldPath} to ${file.path}`);
    this.removePathEntries(oldPath);
    if (file instanceof import_obsidian.TFile) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        this.processBacklinks(cache, file.path);
      }
    }
  }
  handleFileDelete(file) {
    console.debug(`Handling deletion ${file.path}`);
    this.removePathEntries(file.path);
  }
  removePathEntries(path) {
    console.debug(`Removing ${path} entries`);
    this.backlinksMap.delete(path);
    this.removeLinkedPathEntries(path);
  }
  removeLinkedPathEntries(path) {
    var _a;
    console.debug(`Removing linked entries for ${path}`);
    const linkedNotePaths = this.linksMap.get(path) || [];
    for (const linkedNotePath of linkedNotePaths) {
      (_a = this.backlinksMap.get(linkedNotePath)) == null ? void 0 : _a.delete(path);
    }
    this.linksMap.delete(path);
  }
  getBacklinksForFile(file) {
    var _a;
    const notePathLinksMap = this.backlinksMap.get((_a = file == null ? void 0 : file.path) != null ? _a : "") || /* @__PURE__ */ new Map();
    const dict = new CustomArrayDictImpl();
    for (const [notePath, links] of notePathLinksMap.entries()) {
      for (const link of [...links].sort((a, b) => a.position.start.offset - b.position.start.offset)) {
        dict.add(notePath, link);
      }
    }
    return dict;
  }
  extractLinkPath(link) {
    return link.replace(/\u00A0/g, " ").normalize("NFC").split("#")[0];
  }
  processBacklinks(cache, notePath) {
    var _a;
    console.debug(`Processing backlinks for ${notePath}`);
    if (!this.linksMap.has(notePath)) {
      this.linksMap.set(notePath, /* @__PURE__ */ new Set());
    }
    const allLinks = [];
    if (cache.links) {
      allLinks.push(...cache.links);
    }
    if (cache.embeds) {
      allLinks.push(...cache.embeds);
    }
    for (const link of allLinks) {
      const linkFile = this.app.metadataCache.getFirstLinkpathDest(this.extractLinkPath(link.link), notePath);
      if (!linkFile) {
        continue;
      }
      let notePathLinksMap = this.backlinksMap.get(linkFile.path);
      if (!notePathLinksMap) {
        notePathLinksMap = /* @__PURE__ */ new Map();
        this.backlinksMap.set(linkFile.path, notePathLinksMap);
      }
      let linkSet = notePathLinksMap.get(notePath);
      if (!linkSet) {
        linkSet = /* @__PURE__ */ new Set();
        notePathLinksMap.set(notePath, linkSet);
      }
      linkSet.add(link);
      (_a = this.linksMap.get(notePath)) == null ? void 0 : _a.add(linkFile.path);
    }
  }
};
